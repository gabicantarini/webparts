"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageSolutionJsonManager = void 0;
const YeomanConfiguration_1 = require("./YeomanConfiguration");
const JsonManager_1 = require("./JsonManager");
class PackageSolutionJsonManager extends JsonManager_1.JsonManager {
    static load(filepath, fs) {
        if (this._instance) {
            throw new Error(`Cannot create a second instance of PackageSolutionJsonManager`);
        }
        let data;
        try {
            data = fs.readJSON(filepath);
        }
        catch (error) {
            data = undefined;
        }
        if (!data) {
            data = {
                $schema: 'https://developer.microsoft.com/json-schemas/spfx-build/package-solution.schema.json'
            };
        }
        PackageSolutionJsonManager._instance = new PackageSolutionJsonManager(filepath, fs, data);
    }
    static reset() {
        PackageSolutionJsonManager._instance = undefined;
    }
    static get instance() {
        return this._instance;
    }
    getSkipFeatureDeployment() {
        var _a;
        try {
            return !!((_a = this.data.solution) === null || _a === void 0 ? void 0 : _a.skipFeatureDeployment);
        }
        catch (error) {
            return false;
        }
    }
    setUpSolution(solutionContext) {
        const data = this.data;
        data.solution = {
            name: `${solutionContext.libraryName}-client-side-solution`,
            id: solutionContext.libraryId,
            version: '1.0.0.0'
        };
        data.solution.includeClientSideAssets = true;
        if (solutionContext.skipFeatureDeployment) {
            data.solution.skipFeatureDeployment = solutionContext.skipFeatureDeployment;
        }
        if (solutionContext.isDomainIsolated !== undefined) {
            data.solution.isDomainIsolated = solutionContext.isDomainIsolated;
        }
        if (YeomanConfiguration_1.YeomanConfiguration.environment === 'spo') {
            data.solution.developer = {
                name: '',
                websiteUrl: '',
                privacyUrl: '',
                termsOfUseUrl: '',
                mpnId: `Undefined-${YeomanConfiguration_1.YeomanConfiguration.version}`
            };
        }
        data.paths = {
            zippedPackage: `solution/${solutionContext.libraryName}.sppkg`
        };
        data.solution.metadata = {
            shortDescription: {
                default: solutionContext.solutionShortDescription
            },
            longDescription: {
                default: solutionContext.solutionShortDescription
            },
            screenshotPaths: [],
            videoUrl: '',
            categories: []
        };
    }
    addExtensionFeature(featureId, includeClientSideInstance) {
        this.addFeature(featureId, 'Application Extension - Deployment of custom action', 'Deploys a custom action with ClientSideComponentId association', true, includeClientSideInstance);
    }
    addFeature(featureId, title, description, includeAssets, includeClientSideInstance = false) {
        const solution = this.data.solution;
        if (!solution) {
            // This should never happened as the solution has been set up
            return;
        }
        let feature = this._tryGetFeatureToReuse(solution);
        const isAddingFeature = !feature;
        if (!feature) {
            // we could use isAddingFeature flag but it leads to 'possibly undefined' error when using feature below
            if (!solution.features) {
                solution.features = [];
            }
            feature = {
                title: title,
                description: description,
                id: featureId,
                version: '1.0.0.0'
            };
        }
        if (includeAssets) {
            if (!feature.assets) {
                feature.assets = {};
            }
            let manifests = feature.assets.elementManifests;
            if (!manifests) {
                manifests = feature.assets.elementManifests = ['elements.xml'];
            }
            else {
                if (manifests.indexOf('elements.xml') === -1) {
                    manifests.push('elements.xml');
                }
            }
            if (includeClientSideInstance && manifests.indexOf('ClientSideInstance.xml') === -1) {
                manifests.push('ClientSideInstance.xml');
            }
        }
        if (isAddingFeature) {
            solution.features.push(feature);
        }
    }
    /**
     * Returns the existing feature that doesn't have componentIds.
     * We can use the same feature to add additional elements
     */
    _tryGetFeatureToReuse(solution) {
        if (!solution.features) {
            return undefined;
        }
        const noComponendIdsFeatures = solution.features.filter((feature) => !feature.componentIds || !feature.componentIds.length);
        return noComponendIdsFeatures.length ? noComponendIdsFeatures[0] : undefined;
    }
}
exports.PackageSolutionJsonManager = PackageSolutionJsonManager;
//# sourceMappingURL=PackageSolutionJsonManager.js.map