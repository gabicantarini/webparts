"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseGenerator = void 0;
const colors_1 = __importDefault(require("colors"));
const path = __importStar(require("path"));
const UpdateNotifier = __importStar(require("update-notifier"));
const yeoman_generator_1 = __importDefault(require("yeoman-generator"));
const node_core_library_1 = require("@rushstack/node-core-library");
const Utils = __importStar(require("./utilities"));
const PackageJsonManager_1 = require("./PackageJsonManager");
const ConfigJsonManager_1 = require("./ConfigJsonManager");
const ServeJsonManager_1 = require("./ServeJsonManager");
const PackageSolutionJsonManager_1 = require("./PackageSolutionJsonManager");
const YeomanConfiguration_1 = require("./YeomanConfiguration");
class BaseGenerator extends yeoman_generator_1.default {
    constructor(args, options) {
        // Always overwrite the conflict files, without any prompting.
        super(args, !(options.force = true) || options);
        this.allowEmptyPackageJson = false;
        this.copyTemplate = (sourceDirectory, destinationDir) => {
            Utils.filesIn(sourceDirectory).forEach(this._untokenizedCopier(sourceDirectory, destinationDir));
        };
        this.context = {};
        // Register an error handler for uncaught exceptions:
        this.addListener('error', (errorObject) => {
            let errorMessage = '';
            if (errorObject) {
                if (typeof errorObject === 'string') {
                    errorMessage = errorObject || '';
                }
                else if (errorObject instanceof Error) {
                    errorMessage = errorObject.message || '';
                }
            }
            if (!errorMessage.trim()) {
                errorMessage = 'The operation was unsuccessful';
            }
            console.error('\n' + colors_1.default.red('Error: ' + errorMessage));
            process.exitCode = 1;
        });
        // tslint:disable:no-string-literal
        YeomanConfiguration_1.YeomanConfiguration.setStore(this['config']);
        BaseGenerator._checkForUpdates();
        this.option('skip-install', {
            type: Boolean,
            description: 'Skip running package managers (NPM, etc) post scaffolding',
            default: false
        });
    }
    get packageJsonManager() {
        if (!PackageJsonManager_1.PackageJsonManager.instance) {
            PackageJsonManager_1.PackageJsonManager.load(this.destinationPath('package.json'), this.fs);
        }
        if (!this.allowEmptyPackageJson && !PackageJsonManager_1.PackageJsonManager.instance.data) {
            throw new Error(`Cannot find "package.json" file required by this generator`);
        }
        return PackageJsonManager_1.PackageJsonManager.instance;
    }
    get configJson() {
        if (!ConfigJsonManager_1.ConfigJsonManager.instance) {
            ConfigJsonManager_1.ConfigJsonManager.load(this.destinationPath('config/config.json'), this.fs);
        }
        return ConfigJsonManager_1.ConfigJsonManager.instance;
    }
    get serveJson() {
        if (!ServeJsonManager_1.ServeJsonManager.instance) {
            ServeJsonManager_1.ServeJsonManager.load(this.destinationPath('config/serve.json'), this.fs);
        }
        return ServeJsonManager_1.ServeJsonManager.instance;
    }
    get packageSolutionJson() {
        if (!PackageSolutionJsonManager_1.PackageSolutionJsonManager.instance) {
            PackageSolutionJsonManager_1.PackageSolutionJsonManager.load(this.destinationPath('config/package-solution.json'), this.fs);
        }
        return PackageSolutionJsonManager_1.PackageSolutionJsonManager.instance;
    }
    static _checkForUpdates() {
        if (!BaseGenerator._hasCheckedForUpdates) {
            const update = new UpdateNotifier.UpdateNotifier({
                pkg: BaseGenerator.generatorPackageJson
            });
            update.notify({
                defer: false
            });
        }
        BaseGenerator._hasCheckedForUpdates = true;
    }
    /** Where you write the generator specific files (routes, controllers, etc) */
    writing(shouldCopy = true) {
        // Update config to add the webpart entry.
        this.configJson.save();
        // Update package.json dependencies and trigger npm install if necessary.
        this.packageJsonManager.save();
        // Update serve.json to add the new serve configuration.
        this.serveJson.save();
        // Update package-solution.json to add the new packaging configuration.
        this.packageSolutionJson.save();
        if (shouldCopy) {
            this.copyTemplate(this.sourceRoot(), this.destinationRoot());
        }
    }
    tryInstall() {
        const shouldInstall = !this.options['skip-install'];
        if (shouldInstall && YeomanConfiguration_1.YeomanConfiguration.packageManager === 'pnpm') {
            this._doPnpmInstall();
        }
        return shouldInstall;
    }
    ensureCorrectFolder() {
        if (this.config.get('whichFolder') === 'subdir') {
            this.destinationRoot(this.destinationPath());
        }
    }
    ensureDependencyGroup(group) {
        const dependenciesByDependencyGroup = this._ensureDependenciesByDependencyGroup();
        const dependencies = dependenciesByDependencyGroup.get(group);
        for (const [name, version] of Object.entries(dependencies.dependencies)) {
            this.packageJsonManager.addDependency(name, version);
        }
        // before applying devDependencies, dedupe them
        this._dedupeDependencies(dependencies.devDependencies);
        for (const [name, version] of Object.entries(dependencies.devDependencies)) {
            this.packageJsonManager.addDevDependency(name, version);
        }
        // if at any point we are adding some react typings, then ensure they are in the resolutions for Yarn
        this._addResolutionsIfApplicable(['@types/react']);
    }
    nameIsDependencyGroup(name) {
        const dependenciesByDependencyGroup = this._ensureDependenciesByDependencyGroup();
        return dependenciesByDependencyGroup.has(name);
    }
    _ensureDependenciesByDependencyGroup() {
        if (!this._dependenciesByDependencyGroup) {
            const dependenciesFile = node_core_library_1.JsonFile.load(`${__dirname}/dependencies.json`);
            const plusBeta = this.options.plusbeta;
            const dependenciesByDependencyGroup = new Map();
            this._dependenciesByDependencyGroup = dependenciesByDependencyGroup;
            for (const [groupName, groupDependencies] of Object.entries(dependenciesFile)) {
                const dependencyList = {
                    devDependencies: {},
                    ...(plusBeta && groupDependencies.plusBeta
                        ? groupDependencies.plusBeta
                        : groupDependencies.standard)
                };
                dependenciesByDependencyGroup.set(groupName, dependencyList);
            }
        }
        return this._dependenciesByDependencyGroup;
    }
    _dedupeDependencies(devDependencies) {
        // if there is already a dependency and the same devDependency - leave dependency only
        if (!this.packageJsonManager.data.dependencies || !devDependencies) {
            return;
        }
        const { dependencies } = this.packageJsonManager.data;
        Object.keys(devDependencies).forEach((packageName) => {
            if (dependencies[packageName]) {
                delete devDependencies[packageName];
            }
        });
    }
    _addResolutionsIfApplicable(packages) {
        if (this.packageJsonManager.data.dependencies) {
            for (const packageName of packages) {
                let packageVersion;
                if ((packageVersion = this.packageJsonManager.data.dependencies[packageName])) {
                    this.packageJsonManager.addResolution(packageName, packageVersion);
                }
            }
        }
    }
    _doPnpmInstall() {
        // Awaiting: https://github.com/yeoman/generator/pull/1067
        const installer = 'pnpm';
        const args = ['install'];
        // Follow the same pattern as runInstall(), which uses "once" to ensure only
        // one install for both the solution and the component generators.
        // tslint:disable-next-line:no-any
        this.env.runLoop.add('install', (done) => {
            // tslint:disable-line:no-any
            this.emit(installer + 'Install');
            this.spawnCommand(installer, args)
                .on('error', (err) => {
                console.log(colors_1.default.red('Could not finish installation. \n') +
                    'Please install ' +
                    installer +
                    ' with ' +
                    colors_1.default.yellow('npm install -g ' + installer) +
                    ' and try again.');
            })
                .on('exit', (err) => {
                this.emit(installer + 'Install:end');
                done();
            });
        }, { once: installer + ' ' + args.join(' '), run: false });
    }
    _untokenizedCopier(directory, destination) {
        return (filename) => {
            const sourceFile = path.join(directory, filename);
            const destinationFile = path.join(destination, Utils.untokenize(filename, this.context));
            this.fs.copyTpl(sourceFile, destinationFile, this.context);
        };
    }
}
exports.BaseGenerator = BaseGenerator;
BaseGenerator.generatorPackageJson = node_core_library_1.JsonFile.load(`${__dirname}/../../package.json`);
BaseGenerator._hasCheckedForUpdates = false;
//# sourceMappingURL=BaseGenerator.js.map